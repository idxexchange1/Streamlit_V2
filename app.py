# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cKnmDhcYd1B0k20_ctBRG6dlOq-LEt2b
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
from geopy.geocoders import GoogleV3

# Load models
model = joblib.load("model.pkl")
kmeans = joblib.load("kmeans_model.pkl")  # pre-trained KMeans clustering model

# Initialize geocoder with API key from Streamlit secrets
geolocator = GoogleV3(api_key=st.secrets["google_maps_api_key"])

st.title("üè° California House Price Predictor")

# Address input
address = st.text_input("üìç Enter Property Address (optional)")

# If address is entered, geocode it; else manual lat/lon inputs
if address:
    location = geolocator.geocode(address)
    if location is None:
        st.error("‚ùó Could not geocode the address. Please enter a valid address or enter lat/lon manually.")
        # Provide fallback manual lat/lon inputs if address fails
        latitude = st.number_input("Latitude", min_value=32.56, max_value=36.06, value=34.3, step=0.0001)
        longitude = st.number_input("Longitude", min_value=-119.52, max_value=-115.93, value=-117.7, step=0.0001)
    else:
        latitude = location.latitude
        longitude = location.longitude
        st.info(f"üìç Geocoded Location: {latitude:.5f}, {longitude:.5f}")
else:
    latitude = st.number_input("Latitude", min_value=32.56, max_value=36.06, value=34.3, step=0.0001)
    longitude = st.number_input("Longitude", min_value=-119.52, max_value=-115.93, value=-117.7, step=0.0001)

# Other inputs
sqft = st.number_input("Living Area (sqft)", 500, 10000, step=50)
beds = st.number_input("Bedrooms", 0, 10)
baths = st.number_input("Bathrooms", 0, 10)
garage_spaces = st.number_input("Garage Spaces", 0, 5)
lot_size = st.number_input("Lot Size (sqft)", 1000, 20000, step=100)
year_built = st.number_input("Year Built", 1900, 2025)
stories = st.selectbox("Stories", [1, 2, 3])
parking_total = st.number_input("Total Parking Spaces", 0, 10)

attached_garage = st.selectbox("Attached Garage", ["No", "Yes"])
fireplace = st.selectbox("Fireplace", ["No", "Yes"])
pool = st.selectbox("Private Pool", ["No", "Yes"])
view = st.selectbox("Has View", ["No", "Yes"])
new_construction = st.selectbox("New Construction", ["No", "Yes"])

# Predict button
if st.button("Predict Price"):
    # Predict cluster from lat/lon
    cluster = kmeans.predict([[latitude, longitude]])[0]

    input_dict = {
        'LivingArea': sqft,
        'BedroomsTotal': beds,
        'BathroomsTotalInteger': baths,
        'GarageSpaces': garage_spaces,
        'LotSizeSquareFeet': lot_size,
        'YearBuilt': year_built,
        'Stories': stories,
        'ParkingTotal': parking_total,
        'Latitude': latitude,
        'Longitude': longitude,
        'AttachedGarageYN_1': int(attached_garage == "Yes"),
        'FireplaceYN_1': int(fireplace == "Yes"),
        'NewConstructionYN_1': int(new_construction == "Yes"),
        'PoolPrivateYN_1': int(pool == "Yes"),
        'ViewYN_1': int(view == "Yes"),
    }

    # One-hot encode clusters (assuming clusters 2-19 as before)
    for i in range(2, 20):
        col = f'LocationCluster_{float(i)}'
        input_dict[col] = 1 if cluster == i else 0

    # Make sure all model features are present
    input_df = pd.DataFrame([input_dict])
    input_df = input_df.reindex(columns=model.feature_names_in_, fill_value=0)

    # Predict log price and exponentiate
    log_price = model.predict(input_df)[0]
    predicted_price = np.expm1(log_price)

    st.success(f"üí∞ Estimated Home Price: ${predicted_price:,.0f}")
    st.info(f"üìç Latitude: {latitude:.5f}, Longitude: {longitude:.5f}")
    st.info(f"üìä Predicted Location Cluster: {cluster}")

    st.info(f"üìä Predicted Location Cluster: {cluster}")
