# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cKnmDhcYd1B0k20_ctBRG6dlOq-LEt2b
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import requests

# Load the trained Gradient Boosting model
model = joblib.load("model.pkl")

st.title("üè° California House Price Predictor")

# Address input
address = st.text_input("Property Address", "")

# Other inputs
sqft = st.number_input("Living Area (sqft)", 500, 10000, step=50)
beds = st.number_input("Bedrooms", 0, 10)
baths = st.number_input("Bathrooms", 0, 10)
garage_spaces = st.number_input("Garage Spaces", 0, 5)
lot_size = st.number_input("Lot Size (sqft)", 1000, 20000, step=100)
year_built = st.number_input("Year Built", 1900, 2025)
stories = st.selectbox("Stories", [1, 2, 3])
parking_total = st.number_input("Total Parking Spaces", 0, 10)

# Binary inputs
attached_garage = st.selectbox("Attached Garage", ["No", "Yes"])
fireplace = st.selectbox("Fireplace", ["No", "Yes"])
pool = st.selectbox("Private Pool", ["No", "Yes"])
view = st.selectbox("Has View", ["No", "Yes"])
new_construction = st.selectbox("New Construction", ["No", "Yes"])

# Location Cluster (1-19)
location_cluster = st.selectbox("Location Cluster", list(range(1, 20)))

# Geocode function
def geocode_address(addr):
    url = f"https://nominatim.openstreetmap.org/search"
    params = {
        "q": addr,
        "format": "json",
        "limit": 1
    }
    try:
        response = requests.get(url, params=params, headers={"User-Agent": "streamlit-house-predictor"})
        response.raise_for_status()
        data = response.json()
        if data:
            lat = float(data[0]['lat'])
            lon = float(data[0]['lon'])
            return lat, lon
    except Exception as e:
        st.error(f"Geocoding failed: {e}")
    return None, None

# Predict
if st.button("Predict Price"):
    latitude, longitude = geocode_address(address)
    if latitude is None or longitude is None:
        st.error("‚ùå Could not find location for the address.")
    else:
        input_dict = {
            'LivingArea': sqft,
            'BedroomsTotal': beds,
            'BathroomsTotalInteger': baths,
            'GarageSpaces': garage_spaces,
            'LotSizeSquareFeet': lot_size,
            'YearBuilt': year_built,
            'Stories': stories,
            'ParkingTotal': parking_total,
            'Latitude': latitude,
            'Longitude': longitude
        }

        # Binary dummy variables
        dummy_cols = [
            'AttachedGarageYN_1', 'FireplaceYN_1', 'NewConstructionYN_1',
            'PoolPrivateYN_1', 'ViewYN_1'
        ]
        for col in dummy_cols:
            input_dict[col] = 0

        if attached_garage == "Yes":
            input_dict['AttachedGarageYN_1'] = 1
        if fireplace == "Yes":
            input_dict['FireplaceYN_1'] = 1
        if new_construction == "Yes":
            input_dict['NewConstructionYN_1'] = 1
        if pool == "Yes":
            input_dict['PoolPrivateYN_1'] = 1
        if view == "Yes":
            input_dict['ViewYN_1'] = 1

        # Location cluster dummies
        for i in range(2, 20):
            col = f'LocationCluster_{float(i)}'
            input_dict[col] = 1 if location_cluster == i else 0

        # Convert to DataFrame
        input_df = pd.DataFrame([input_dict])

        # Align columns with model
        model_features = model.feature_names_in_
        input_df = input_df.reindex(columns=model_features, fill_value=0)

        # Predict
        log_price = model.predict(input_df)[0]
        predicted_price = np.expm1(log_price)

        st.success(f"üí∞ Estimated Home Price: ${predicted_price:,.0f}")

